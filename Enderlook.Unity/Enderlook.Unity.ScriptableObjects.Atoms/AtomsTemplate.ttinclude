<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#+
    void WriteHeader()
    {
#>
//====================================================================================================
//                      THIS IS AN AUTOGENERATED FILE. DO NOT EDIT MANUALLY
//====================================================================================================
using Enderlook.Unity.Attributes;

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

using UnityEngine;
using UnityObject = UnityEngine.Object;

namespace Enderlook.Unity.ScriptableObjects.Atoms
{
<#+
    }
    const string menuName = "Enderlook/Atoms";
    void Generate(string name, string dataType)
    {
        string atomGet = name + "Get";
        string atomConstant = name + "Constant";

        string atomGetSet = name + "GetSet";
        string atomVariable = name + "Variable";

        string atomGetAdapter = name + "GetAdapter";
        string atomGetSetAdapter = name + "GetSetAdapter";

        string path = "Atoms/" + name;

        WriteHeader();
#>
    [Serializable]
    public abstract class <#= atomGet #> : Atom, IAtomConstant<<#= dataType #>>
    {
        public abstract <#= dataType #> GetValue();
    }

    [Serializable]
    public abstract class <#= atomGetSet #> : <#= atomGet #>, IAtomVariable<<#= dataType #>>
    {
        public abstract void SetValue(<#= dataType #> value);
    }
<#+
        SaveOutput(name + "Abstracts", path);
        WriteHeader();
#>
    [Serializable]
    [CreateAssetMenu(fileName = "<#= atomConstant #>", menuName = "<#= menuName #>/Variables/Constants/<#= name #>")]
    public class <#= atomConstant #> : <#= atomGet #>
    {
        [SerializeField, Tooltip("Value stored in this atom.")]
        protected <#= dataType #> value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override <#= dataType #> GetValue() => value;

        /// <summary>
        <#= "///" #> Create new <see cref="<#= atomConstant #>"/> with given value.
        /// </summary>
        <#= "///" #> <param name="value">Value of new <see cref="<#= atomConstant #>"/>.</param>
        <#= "///" #> <returns>New <see cref="<#= atomConstant #>"/>.</returns>
        public static <#= atomConstant #> CreateConstant(<#= dataType #> value)
        {
            <#= atomConstant #> atom = CreateInstance<<#= atomConstant #>>();
            atom.value = value;
            return atom;
        }
<#+ WriteEquality(atomConstant, dataType); #>
    }
<#+
        SaveOutput(atomConstant, path);
        WriteHeader();
#>
    [Serializable]
    [CreateAssetMenu(fileName = "<#= atomGetAdapter #>", menuName = "<#= menuName #>/Variables/Adapters/Get/<#= name #>")]
    public class <#= atomGetAdapter #> : <#= atomGet #>
    {
#pragma warning disable CA2235
        [SerializeField, RestrictType(typeof(IGet<<#= dataType #>>)), Tooltip("Object that produces value of this atom.\nIf you change this value in Editor you must execute Refesh method.")]
        private UnityObject wrapped;
#pragma warning restore CA2235

        private IGet<<#= dataType #>> getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override <#= dataType #> GetValue() => getter.GetValue();

        public void OnEnable() => getter = (IGet<<#= dataType #>>)wrapped;

#if UNITY_EDITOR
        public void Refesh() => getter = (IGet<<#= dataType #>>)wrapped;
#endif

        /// <summary>
        <#= "///" #> Create new <see cref="<#= atomConstant #>"/> with given wrapped.
        /// </summary>
        <#= "///" #> <param name="wrapped">Value of new <see cref="<#= atomGetAdapter #>"/>.</param>
        <#= "///" #> <returns>New <see cref="<#= atomGetAdapter #>"/>.</returns>
        public static <#= atomGetAdapter #> CreateConstant<T>(T wrapped) where T : UnityObject, IGet<<#= dataType #>>
        {
            <#= atomGetAdapter #> atom = CreateInstance<<#= atomGetAdapter #>>();
            atom.getter = wrapped;
            atom.wrapped = wrapped;
            return atom;
        }
    }
<#+
        SaveOutput(atomGetAdapter, path);
        WriteHeader();
#>
    [Serializable]
    [CreateAssetMenu(fileName = "<#= name #>Variable", menuName = "<#= menuName #>/Variables/Commons/<#= name #>")]
    public class <#= atomVariable #> : <#= atomGetSet #>
    {
        [SerializeField, Tooltip("Value stored in this atom.")]
        protected <#= dataType #> value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override <#= dataType #> GetValue() => value;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override void SetValue(<#= dataType #> value) => this.value = value;

        /// <summary>
        <#= "///" #> Create new <see cref="<#= atomVariable #>"/> with given value.
        /// </summary>
        <#= "///" #> <param name="value">Value of new <see cref="<#= atomVariable #>"/>.</param>
        <#= "///" #> <returns>New <see cref="<#= atomVariable #>"/>.</returns>
        public static <#= atomVariable #> CreateConstant(<#= dataType #> value)
        {
            <#= atomVariable #> atom = CreateInstance<<#= atomVariable #>>();
            atom.value = value;
            return atom;
        }

<#+ WriteEquality(atomVariable, dataType); #>
    }
<#+
        SaveOutput(atomVariable, path);
        WriteHeader();
#>
    [Serializable]
    [CreateAssetMenu(fileName = "<#= name #>Constant", menuName = "<#= menuName #>/Variables/Adapters/GetSet/<#= name #>")]
    public class <#= atomGetSetAdapter #> : <#= atomGet #>
    {
#pragma warning disable CA2235
        [SerializeField, RestrictType(typeof(IGetSet<<#= dataType #>>)), Tooltip("Object that produces value of this atom.\nIf you change this value in Editor you must execute Refesh method.")]
        private UnityObject wrapped;
#pragma warning restore CA2235

        protected IGet<<#= dataType #>> getter;

        public override <#= dataType #> GetValue() => getter.GetValue();

        public void OnEnable() => getter = (IGet<<#= dataType #>>)wrapped;

#if UNITY_EDITOR
        public void Refesh() => getter = (IGet<<#= dataType #>>)wrapped;
#endif

        /// <summary>
        <#= "///" #> Create new <see cref="<#= atomConstant #>"/> with given wrapped.
        /// </summary>
        <#= "///" #> <param name="wrapped">Value of new <see cref="<#= atomGetSetAdapter #>"/>.</param>
        <#= "///" #> <returns>New <see cref="<#= atomGetSetAdapter #>"/>.</returns>
        public static <#= atomGetSetAdapter #> CreateConstant<T>(T wrapped) where T : UnityObject, IGet<<#= dataType #>>
        {
            <#= atomGetSetAdapter #> atom = CreateInstance<<#= atomGetSetAdapter #>>();
            atom.getter = wrapped;
            atom.wrapped = wrapped;
            return atom;
        }
    }
<#+
        SaveOutput(atomGetSetAdapter, path);
    }

    void WriteEquality(string className, string dataType)
    {
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool Equals(<#= className #> other) => EqualityComparer<<#= dataType #>>.Default.Equals(GetValue(), other.GetValue());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => GetValue().GetHashCode();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(<#= className #> left, <#= className #> right) => left.Equals(right);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(<#= className #> left, <#= className #> right) => left.Equals(right);

        public override bool Equals(object obj)
        {
            if (obj == null)
                return false;
            if (ReferenceEquals(this, obj))
                return true;
            if (obj is <#= className #> element)
                return Equals(element);
            return false;
        }
<#+
    }

    void SaveOutput(string fileName, string path = "")
    {
#>
}
<#+
        fileName += ".autogenerated.cs";
        string templateDirectory = Path.GetDirectoryName(Host.TemplateFile);
        string outputFilePath = Path.Combine(templateDirectory, path);
        if (!string.IsNullOrEmpty(path))
            Directory.CreateDirectory(outputFilePath);
        outputFilePath = Path.Combine(outputFilePath, fileName);
        File.WriteAllText(outputFilePath, this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
    }
#>